package cmd

import (
    "fmt"
    "os"
    "path/filepath"
    "strings"
    "encoding/json"
    "github.com/spf13/cobra"

    "helm.sh/helm/v3/pkg/chart"
    "helm.sh/helm/v3/pkg/chart/loader"
    "helm.sh/helm/v3/pkg/chartutil"
    "helm.sh/helm/v3/pkg/engine"
    "helm.sh/helm/v3/pkg/action"
    "gopkg.in/yaml.v2"
)

var configPath string
var umbrellaChartPath string
var subchartChartPath string


// ChartMetadata represents the structure of Chart.yaml
type ChartMetadata struct {
    APIVersion  string                   `yaml:"apiVersion"`
    Name        string                   `yaml:"name"`
    Version     string                   `yaml:"version"`
    Description string                   `yaml:"description,omitempty"`
    Dependencies []chart.Dependency      `yaml:"dependencies,omitempty"`
}

func renderChart(chartPath string, values map[string]interface{}) error {
    // Load the chart from the specified path
    ch, err := loader.Load(chartPath)
    if err != nil {
        return fmt.Errorf("failed to load chart: %w", err)
    }

    // Create a new engine instance
    e := engine.Engine{}

    // Render the chart with the provided values
    rendered, err := e.Render(ch, chartutil.Values(values))
    if err != nil {
        return fmt.Errorf("failed to render chart: %w", err)
    }

    // Output the rendered templates
    for name, content := range rendered {
        fmt.Printf("=== %s ===\n%s\n", name, content)
    }

    return nil
}

func loadUmbrellaChart(path string) (*chart.Chart, error) {
    ch, err := loader.Load(path)
    if err != nil {
        return nil, fmt.Errorf("failed to load chart: %w", err)
    }
    return ch, nil
}


type Config struct {
    UmbrellaChartName string     `yaml:"umbrellaChartName"`
    Subcharts         []Subchart `yaml:"subcharts"`
}

type Subchart struct {
    Name     string `yaml:"name"`
    Workload string `yaml:"workload"`
}

func loadConfig(path string) (*Config, error) {
    data, err := os.ReadFile(path)
    if err != nil {
        return nil, fmt.Errorf("failed to read config file: %w", err)
    }

    var cfg Config
    if err := yaml.Unmarshal(data, &cfg); err != nil {
        return nil, fmt.Errorf("failed to unmarshal config YAML: %w", err)
    }

    return &cfg, nil
}


func loadChart(chartPath string) (*chart.Chart, error) {
    ch, err := loader.Load(chartPath)
    if err != nil {
        return nil, fmt.Errorf("failed to load chart from %s: %w", chartPath, err)
    }
    return ch, nil
}


// with the parent chart's name in templates and files, and adds it as a dependency.
func newSubchart(parentChart *chart.Chart, subchartPath, subchartName string) (*chart.Chart, error) {
    // Load the subchart
    subchart, err := loader.Load(subchartPath)
    if err != nil {
        return nil, fmt.Errorf("failed to load subchart: %w", err)
    }

    // Rename the subchart
    subchart.Metadata.Name = subchartName

    // Define placeholders and their replacements
    replacements := map[string]string{
        "umbrella-chart": parentChart.Metadata.Name,
        "component":      subchartName,
    }

    // Replace placeholders in templates
    for _, tmpl := range subchart.Templates {
        content := string(tmpl.Data)
        for old, new := range replacements {
            content = strings.ReplaceAll(content, old, new)
        }
        tmpl.Data = []byte(content)
    }

    // Replace placeholders in additional files
    for _, file := range subchart.Files {
        content := string(file.Data)
        for old, new := range replacements {
            content = strings.ReplaceAll(content, old, new)
        }
        file.Data = []byte(content)
    }


    // Add the subchart to the parent chart's dependencies
    parentChart.AddDependency(subchart)

    // Update the parent chart's metadata dependencies
    // Assuming parentChart.Metadata.Dependencies is of type []*chart.Dependency
    newDependency := &chart.Dependency{
        Name:       subchartName,
        Version:    subchart.Metadata.Version,
        Repository: fmt.Sprintf("file://charts/%s", subchartName),
    }
    parentChart.Metadata.Dependencies = append(parentChart.Metadata.Dependencies, newDependency)
    return parentChart, nil
}

// saveChartAsDir recursively saves a chart and its subcharts as directories.
func saveChartAsDir(ch *chart.Chart, dest string) error {
    chartPath := filepath.Join(dest, ch.Metadata.Name)

    // Ensure the destination directory exists
    if err := os.MkdirAll(chartPath, 0755); err != nil {
        return fmt.Errorf("failed to create directory %s: %w", chartPath, err)
    }

    // Save the main chart
    if err := chartutil.SaveDir(ch, dest); err != nil {
        return fmt.Errorf("failed to save chart %s: %w", ch.Metadata.Name, err)
    }

    // Recursively save subcharts
    for _, dep := range ch.Dependencies() {
        subchartDest := filepath.Join(chartPath, "charts")
        if err := saveChartAsDir(dep, subchartDest); err != nil {
            return err
        }
    }

    return nil
}

func listChartDependencies(chartPath string) error {
    // Create a new Dependency action
    dep := action.NewDependency()

    // List the dependencies of the chart
    if err := dep.List(chartPath, os.Stdout); err != nil {
        return fmt.Errorf("failed to list dependencies: %w", err)
    }

    return nil
}
func renameChart(ch *chart.Chart, newName string) (*chart.Chart, error) {
    originalName := ch.Metadata.Name
    ch.Metadata.Name = newName

    // Update references in templates
    for _, tmpl := range ch.Templates {
        tmpl.Data = []byte(strings.ReplaceAll(string(tmpl.Data), originalName, newName))
    }

    // Update references in values.yaml
    if ch.Values != nil {
        valuesYAML, err := yaml.Marshal(ch.Values)
        if err != nil {
            return nil, fmt.Errorf("failed to marshal values.yaml: %w", err)
        }
        updatedValues := strings.ReplaceAll(string(valuesYAML), originalName, newName)
        var newValues map[string]interface{}
        if err := yaml.Unmarshal([]byte(updatedValues), &newValues); err != nil {
            return nil, fmt.Errorf("failed to unmarshal updated values.yaml: %w", err)
        }
        ch.Values = newValues
    }

    // Update references in additional files
    for _, file := range ch.Files {
        file.Data = []byte(strings.ReplaceAll(string(file.Data), originalName, newName))
    }

    return ch, nil
}

func saveChart(ch *chart.Chart, outputDir string) error {
    newChartPath := filepath.Join(outputDir, ch.Metadata.Name)

    // Ensure the output directory exists
    if err := os.MkdirAll(newChartPath, 0755); err != nil {
        return fmt.Errorf("failed to create output directory: %w", err)
    }

    // Save the modified chart
    if err := chartutil.SaveDir(ch, newChartPath); err != nil {
        return fmt.Errorf("failed to save modified chart: %w", err)
    }

    fmt.Printf("Modified chart saved to: %s\n", newChartPath)
    return nil
}

func cloneAndRenameChart(baseChartPath, newChartName, outputDir string) error {
    // Load the base chart
    ch, err := loadChart(baseChartPath)
    if err != nil {
        return err
    }

    // Rename the chart and capture the modified chart
    ch, err = renameChart(ch, newChartName)
    if err != nil {
        return err
    }

    // Save the modified chart to the specified output directory
    if err := saveChart(ch, outputDir); err != nil {
        return err
    }

    return nil
}


// inspectChart provides a detailed overview of the given Helm chart.
func inspectChart(ch *chart.Chart) {
    fmt.Println("=== Chart Metadata ===")
    if ch.Metadata != nil {
        metadataBytes, err := json.MarshalIndent(ch.Metadata, "", "  ")
        if err != nil {
            fmt.Printf("Error marshaling metadata: %v\n", err)
        } else {
            fmt.Println(string(metadataBytes))
        }
    } else {
        fmt.Println("No metadata available.")
    }

    fmt.Println("\n=== Templates ===")
    if len(ch.Templates) > 0 {
        for _, tmpl := range ch.Templates {
            fmt.Printf("- %s (%d bytes)\n", tmpl.Name, len(tmpl.Data))
        }
    } else {
        fmt.Println("No templates found.")
    }

    fmt.Println("\n=== Values ===")
    if len(ch.Values) > 0 {
        valuesBytes, err := json.MarshalIndent(ch.Values, "", "  ")
        if err != nil {
            fmt.Printf("Error marshaling values: %v\n", err)
        } else {
            fmt.Println(string(valuesBytes))
        }
    } else {
        fmt.Println("No values defined.")
    }

    fmt.Println("\n=== Files ===")
    if len(ch.Files) > 0 {
        for _, file := range ch.Files {
            fmt.Printf("- %s (%d bytes)\n", file.Name, len(file.Data))
        }
    } else {
        fmt.Println("No additional files found.")
    }

    fmt.Println("\n=== Dependencies ===")
    if len(ch.Dependencies()) > 0 {
        for _, dep := range ch.Dependencies() {
            fmt.Printf("- %s (version: %s)\n", dep.Metadata.Name, dep.Metadata.Version)
        }
    } else {
        fmt.Println("No dependencies found.")
    }

    fmt.Println("\n=== CRDs ===")
    crds := ch.CRDObjects()
    if len(crds) > 0 {
        for _, crd := range crds {
            fmt.Printf("- %s (%d bytes)\n", crd.Name, len(crd.File.Data))
        }
    } else {
        fmt.Println("No CRDs found.")
    }

    fmt.Println("\n=== Schema ===")
    if len(ch.Schema) > 0 {
        fmt.Printf("%s\n", string(ch.Schema))
    } else {
        fmt.Println("No schema defined.")
    }
}

func listSubcharts(ch *chart.Chart) {
    fmt.Println("Subcharts:")
    for _, subchart := range ch.Dependencies() {
        fmt.Printf("- %s (version: %s)\n", subchart.Metadata.Name, subchart.Metadata.Version)
    }
}



var rootCmd = &cobra.Command{
    Use:   "umbrella-cli",
    Short: "CLI tool to define an umbrella Helm chart",
    RunE: func(cmd *cobra.Command, args []string) error {
        cfg, err := loadConfig(configPath)
        if err != nil {
            return fmt.Errorf("failed to load config: %w", err)
        }

        // Create subcharts based on the configuration
        var subcharts []*chart.Chart
        for _, sc := range cfg.Subcharts {
            subchart := &chart.Chart{
                Metadata: &chart.Metadata{
                    Name:        sc.Name,
                    Version:     "0.1.0",
                    Description: fmt.Sprintf("%s service", sc.Name),
                    APIVersion:  "v2",
                },
                Values: map[string]interface{}{
                    "workload": sc.Workload,
                },
            }
            subcharts = append(subcharts, subchart)
        }

        // Create the umbrella chart
        umbrellaChart := &chart.Chart{
            Metadata: &chart.Metadata{
                Name:        cfg.UmbrellaChartName,
                Version:     "1.0.0",
                Description: "An umbrella chart aggregating multiple subcharts",
                APIVersion:  "v2",
            },
            Values: map[string]interface{}{
                "global": map[string]interface{}{
                    "imagePullPolicy": "IfNotPresent",
                    "replicas":        3,
                },
            },
        }

        // Set dependencies using the provided method
        umbrellaChart.SetDependencies(subcharts...)

        // For demonstration, print the chart's metadata
        fmt.Printf("Umbrella Chart: %s\n", umbrellaChart.Metadata.Name)
        fmt.Printf("Version: %s\n", umbrellaChart.Metadata.Version)
        fmt.Printf("Description: %s\n", umbrellaChart.Metadata.Description)

        return nil
    },
}

func init() {
    rootCmd.Flags().StringVarP(&configPath, "config", "c", "config.yaml", "Path to the configuration YAML file")
    rootCmd.Flags().StringVarP(&umbrellaChartPath, "umbrella-base", "u", "templates/umbrella", "Path to the Umbrella base chart")
    rootCmd.Flags().StringVarP(&subchartChartPath, "subchart-base", "s", "templates/subchart", "Path to the Subchart base chart")
}

// Execute adds all child commands to the root command and sets flags appropriately.
func Execute() {
	if err := rootCmd.Execute(); err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
}


func inspect(path string) {
    chart, err := loadUmbrellaChart(path)
    if err != nil {
        fmt.Println("Error:", err)
        return
    }

    inspectChart(chart)
    listSubcharts(chart)
}

func exec() {
    // Load configuration
    cfg, err := loadConfig("config.yaml")
    if err != nil {
        fmt.Println("Error loading config:", err)
        return
    }
    // Load the umbrella chart
    ch, err := loadChart(umbrellaChartPath)
    if err != nil {
        fmt.Println("Error loading umbrella chart:", err)
        return
    }

    // Rename the umbrella chart
    chNew, err := renameChart(ch, cfg.UmbrellaChartName)
    if err != nil {
        fmt.Println("Error renaming umbrella chart:", err)
        return
    }

    // Add each subchart from config
    for _, sc := range cfg.Subcharts {
        chNew, err = newSubchart(chNew, subchartChartPath, sc.Name)
        if err != nil {
            fmt.Printf("Error adding subchart '%s': %v\n", sc.Name, err)
            return
        }
    }

    // Inspect and list subcharts
    //inspectChart(chNew)
    //listSubcharts(chNew)

    // Save the modified umbrella chart
    if err := saveChartAsDir(chNew, "output"); err != nil {
        fmt.Println("Error saving chart:", err)
        return
    }
}
// func test() {
//     // Load the umbrella chart
//     ch, err := loadChart(umbrellaChartPath)
//     if err != nil {
//         fmt.Println("Error loading umbrella chart:", err)
//         return
//     }
// 
//     // Rename the umbrella chart
//     chNew, err := renameChart(ch, "platform")
//     if err != nil {
//         fmt.Println("Error renaming umbrella chart:", err)
//         return
//     }
// 
//     // Define subchart names
//     subchartNames := []string{"frontend", "cache", "database"}
// 
//     // Add each subchart
//     for _, name := range subchartNames {
//         if chNew, err := newSubchart(chNew, subchartChartPath, name); err != nil {
//             fmt.Printf("Error adding subchart '%s': %v\n", name, err)
//             return
//         }
//     }
// 
//     // Inspect and list subcharts
//     inspectChart(chNew)
//     listSubcharts(chNew)
// 
//     // Save the modified umbrella chart
//     if err := saveChartAsDir(chNew, "output"); err != nil {
//         fmt.Println("Error saving chart:", err)
//         return
//     }
// }


// func newSubchart(parent *chart.Chart, subchartPath, subchartName string) error {
//     // Load the base subchart
//     sch, err := loadChart(subchartPath)
//     if err != nil {
//         return fmt.Errorf("failed to load subchart '%s': %w", subchartName, err)
//     }
// 
//     // Rename the subchart
//     schRenamed, err := renameChart(sch, subchartName)
//     if err != nil {
//         return fmt.Errorf("failed to rename subchart '%s': %w", subchartName, err)
//     }
// 
//     // Add the renamed subchart as a dependency
//     parent.AddDependency(schRenamed)
//     return nil
// }

// newSubchart loads a subchart, renames it, adds it as a dependency to the parent chart,
// and returns the updated parent chart.
