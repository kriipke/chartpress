package cmd

import (
    "fmt"
    "os"
    "path/filepath"
    "strings"
    "encoding/json"

    "helm.sh/helm/v3/pkg/chartutil"

    "helm.sh/helm/v3/pkg/chart"
    "helm.sh/helm/v3/pkg/chart/loader"
    "github.com/spf13/cobra"
    "github.com/spf13/viper"
    "log"
    "helm.sh/helm/v3/pkg/engine"
    "helm.sh/helm/v3/pkg/action"
    "gopkg.in/yaml.v2"
)

var (
    name               string
    configPath         string
    umbrellaChartPath  string
    subchartChartPath  string
)


func loadConfig(path string) {
    viper.SetConfigName("config")   // name of config file (without extension)
    viper.SetConfigType("yaml")     // or viper.SetConfigType("yml")
    viper.AddConfigPath(path)       // path to look for the config file

    err := viper.ReadInConfig()     // Find and read the config file
    if err != nil {
        log.Fatalf("Error reading config file: %v\n", err)
    }

    fmt.Println("Loaded config from:", viper.ConfigFileUsed())
}

var createCmd = &cobra.Command{
    Use:   "create",
    Short: "Creates a new umbrella chart with the given name and config file",
    Run: func(cmd *cobra.Command, args []string) {
        // Load from Viper (after itâ€™s bound to the flag)
        config := viper.GetString("config")
        fmt.Printf("Creating chart: %s\n", name)
        fmt.Printf("Using config: %s\n", config)
        create()
    },
}

func init() {
    createCmd.Flags().StringVarP(&name, "name", "n", "", "Name of the new chart")

    // Mark required flags
    createCmd.MarkFlagRequired("name")
    createCmd.MarkFlagRequired("config")

    // Bind flags to Viper
    viper.BindPFlag("config", createCmd.Flags().Lookup("config"))

    createCmd.AddCommand(createCmd)
}

// ChartMetadata represents the structure of Chart.yaml
type ChartMetadata struct {
    APIVersion  string                   `yaml:"apiVersion"`
    Name        string                   `yaml:"name"`
    Version     string                   `yaml:"version"`
    Description string                   `yaml:"description,omitempty"`
    Dependencies []chart.Dependency      `yaml:"dependencies,omitempty"`
}

func renderChart(chartPath string, values map[string]interface{}) error {
    // Load the chart from the specified path
    ch, err := loader.Load(chartPath)
    if err != nil {
        return fmt.Errorf("failed to load chart: %w", err)
    }

    // Create a new engine instance
    e := engine.Engine{}

    // Render the chart with the provided values
    rendered, err := e.Render(ch, chartutil.Values(values))
    if err != nil {
        return fmt.Errorf("failed to render chart: %w", err)
    }

    // Output the rendered templates
    for name, content := range rendered {
        fmt.Printf("=== %s ===\n%s\n", name, content)
    }

    return nil
}

func loadUmbrellaChart(path string) (*chart.Chart, error) {
    ch, err := loader.Load(path)
    if err != nil {
        return nil, fmt.Errorf("failed to load chart: %w", err)
    }
    return ch, nil
}


type Config struct {
    UmbrellaChartName string     `yaml:"umbrellaChartName"`
    Subcharts         []Subchart `yaml:"subcharts"`
}

type Subchart struct {
    Name     string `yaml:"name"`
    Workload string `yaml:"workload"`
}


func loadChart(chartPath string) (*chart.Chart, error) {
    ch, err := loader.Load(chartPath)
    if err != nil {
        return nil, fmt.Errorf("failed to load chart from %s: %w", chartPath, err)
    }
    return ch, nil
}


// with the parent chart's name in templates and files, and adds it as a dependency.
func newSubchart(parentChart *chart.Chart, subchartPath, subchartName string) (*chart.Chart, error) {
    // Load the subchart
    subchart, err := loader.Load(subchartPath)
    if err != nil {
        return nil, fmt.Errorf("failed to load subchart: %w", err)
    }

    // Rename the subchart
    subchart.Metadata.Name = subchartName

    // Define placeholders and their replacements
    replacements := map[string]string{
        "umbrella-chart": parentChart.Metadata.Name,
        "component":      subchartName,
    }

    // Replace placeholders in templates
    for _, tmpl := range subchart.Templates {
        content := string(tmpl.Data)
        for old, new := range replacements {
            content = strings.ReplaceAll(content, old, new)
        }
        tmpl.Data = []byte(content)
    }

    // Replace placeholders in additional files
    for _, file := range subchart.Files {
        content := string(file.Data)
        for old, new := range replacements {
            content = strings.ReplaceAll(content, old, new)
        }
        file.Data = []byte(content)
    }


    // Add the subchart to the parent chart's dependencies
    parentChart.AddDependency(subchart)

    // Update the parent chart's metadata dependencies
    // Assuming parentChart.Metadata.Dependencies is of type []*chart.Dependency
    newDependency := &chart.Dependency{
        Name:       subchartName,
        Version:    subchart.Metadata.Version,
        Repository: fmt.Sprintf("file://charts/%s", subchartName),
    }
    parentChart.Metadata.Dependencies = append(parentChart.Metadata.Dependencies, newDependency)
    return parentChart, nil
}

// saveChartAsDir recursively saves a chart and its subcharts as directories.
func saveChartAsDir(ch *chart.Chart, dest string) error {
    chartPath := filepath.Join(dest, ch.Metadata.Name)

    // Ensure the destination directory exists
    if err := os.MkdirAll(chartPath, 0755); err != nil {
        return fmt.Errorf("failed to create directory %s: %w", chartPath, err)
    }

    // Save the main chart
    if err := chartutil.SaveDir(ch, dest); err != nil {
        return fmt.Errorf("failed to save chart %s: %w", ch.Metadata.Name, err)
    }

    // Recursively save subcharts
    for _, dep := range ch.Dependencies() {
        subchartDest := filepath.Join(chartPath, "charts")
        if err := saveChartAsDir(dep, subchartDest); err != nil {
            return err
        }
    }

    return nil
}

func listChartDependencies(chartPath string) error {
    // Create a new Dependency action
    dep := action.NewDependency()

    // List the dependencies of the chart
    if err := dep.List(chartPath, os.Stdout); err != nil {
        return fmt.Errorf("failed to list dependencies: %w", err)
    }

    return nil
}
func renameChart(ch *chart.Chart, newName string) (*chart.Chart, error) {
    originalName := ch.Metadata.Name
    ch.Metadata.Name = newName

    // Update references in templates
    for _, tmpl := range ch.Templates {
        tmpl.Data = []byte(strings.ReplaceAll(string(tmpl.Data), originalName, newName))
    }

    // Update references in values.yaml
    if ch.Values != nil {
        valuesYAML, err := yaml.Marshal(ch.Values)
        if err != nil {
            return nil, fmt.Errorf("failed to marshal values.yaml: %w", err)
        }
        updatedValues := strings.ReplaceAll(string(valuesYAML), originalName, newName)
        var newValues map[string]interface{}
        if err := yaml.Unmarshal([]byte(updatedValues), &newValues); err != nil {
            return nil, fmt.Errorf("failed to unmarshal updated values.yaml: %w", err)
        }
        ch.Values = newValues
    }

    // Update references in additional files
    for _, file := range ch.Files {
        file.Data = []byte(strings.ReplaceAll(string(file.Data), originalName, newName))
    }

    return ch, nil
}

func saveChart(ch *chart.Chart, outputDir string) error {
    newChartPath := filepath.Join(outputDir, ch.Metadata.Name)

    // Ensure the output directory exists
    if err := os.MkdirAll(newChartPath, 0755); err != nil {
        return fmt.Errorf("failed to create output directory: %w", err)
    }

    // Save the modified chart
    if err := chartutil.SaveDir(ch, newChartPath); err != nil {
        return fmt.Errorf("failed to save modified chart: %w", err)
    }

    fmt.Printf("Modified chart saved to: %s\n", newChartPath)
    return nil
}

func cloneAndRenameChart(baseChartPath, newChartName, outputDir string) error {
    // Load the base chart
    ch, err := loadChart(baseChartPath)
    if err != nil {
        return err
    }

    // Rename the chart and capture the modified chart
    ch, err = renameChart(ch, newChartName)
    if err != nil {
        return err
    }

    // Save the modified chart to the specified output directory
    if err := saveChart(ch, outputDir); err != nil {
        return err
    }

    return nil
}


// inspectChart provides a detailed overview of the given Helm chart.
func inspectChart(ch *chart.Chart) {
    fmt.Println("=== Chart Metadata ===")
    if ch.Metadata != nil {
        metadataBytes, err := json.MarshalIndent(ch.Metadata, "", "  ")
        if err != nil {
            fmt.Printf("Error marshaling metadata: %v\n", err)
        } else {
            fmt.Println(string(metadataBytes))
        }
    } else {
        fmt.Println("No metadata available.")
    }

    fmt.Println("\n=== Templates ===")
    if len(ch.Templates) > 0 {
        for _, tmpl := range ch.Templates {
            fmt.Printf("- %s (%d bytes)\n", tmpl.Name, len(tmpl.Data))
        }
    } else {
        fmt.Println("No templates found.")
    }

    fmt.Println("\n=== Values ===")
    if len(ch.Values) > 0 {
        valuesBytes, err := json.MarshalIndent(ch.Values, "", "  ")
        if err != nil {
            fmt.Printf("Error marshaling values: %v\n", err)
        } else {
            fmt.Println(string(valuesBytes))
        }
    } else {
        fmt.Println("No values defined.")
    }

    fmt.Println("\n=== Files ===")
    if len(ch.Files) > 0 {
        for _, file := range ch.Files {
            fmt.Printf("- %s (%d bytes)\n", file.Name, len(file.Data))
        }
    } else {
        fmt.Println("No additional files found.")
    }

    fmt.Println("\n=== Dependencies ===")
    if len(ch.Dependencies()) > 0 {
        for _, dep := range ch.Dependencies() {
            fmt.Printf("- %s (version: %s)\n", dep.Metadata.Name, dep.Metadata.Version)
        }
    } else {
        fmt.Println("No dependencies found.")
    }

    fmt.Println("\n=== CRDs ===")
    crds := ch.CRDObjects()
    if len(crds) > 0 {
        for _, crd := range crds {
            fmt.Printf("- %s (%d bytes)\n", crd.Name, len(crd.File.Data))
        }
    } else {
        fmt.Println("No CRDs found.")
    }

    fmt.Println("\n=== Schema ===")
    if len(ch.Schema) > 0 {
        fmt.Printf("%s\n", string(ch.Schema))
    } else {
        fmt.Println("No schema defined.")
    }
}

func listSubcharts(ch *chart.Chart) {
    fmt.Println("Subcharts:")
    for _, subchart := range ch.Dependencies() {
        fmt.Printf("- %s (version: %s)\n", subchart.Metadata.Name, subchart.Metadata.Version)
    }
}





func inspect(path string) {
    chart, err := loadUmbrellaChart(path)
    if err != nil {
        fmt.Println("Error:", err)
        return
    }

    inspectChart(chart)
    listSubcharts(chart)
}

func create() {
    loadConfig(".")  // Looks for ./config.yaml

    subcharts := viper.Get("subcharts")
    fmt.Println("subcharts =", subcharts)

    // Load the umbrella chart
    ch, err := loadChart(umbrellaChartPath)
    if err != nil {
        fmt.Println("Error loading umbrella chart:", err)
        return
    }

    // Rename the umbrella chart
    chartName := viper.Get("umbrellaChartName").(string)
    chNew, err := renameChart(ch, chartName )
    if err != nil {
        fmt.Println("Error renaming umbrella chart:", err)
        return
    }

    // Add each subchart from config
    for _, sc := range subcharts {
        chNew, err = newSubchart(chNew, subchartChartPath, sc.Name)
        if err != nil {
            fmt.Printf("Error adding subchart '%s': %v\n", sc.Name, err)
            return
        }
    }
}
